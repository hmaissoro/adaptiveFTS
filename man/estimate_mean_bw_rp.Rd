% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/04_estimate_mean.R
\name{estimate_mean_bw_rp}
\alias{estimate_mean_bw_rp}
\title{Bandwidth estimation using cross-validation for the \insertCite{rubin2020;textual}{adaptiveFTS} mean function estimator.}
\usage{
estimate_mean_bw_rp(
  data,
  idcol = "id_curve",
  tcol = "tobs",
  ycol = "X",
  Kfold = 10,
  bw_grid = seq(0.001, 0.15, len = 45),
  smooth_ker = kernel_epanechnikov
)
}
\arguments{
\item{data}{A \code{data.table} (or \code{data.frame}), a \code{list} of \code{data.table} (or \code{data.frame}), or a \code{list} of \code{list}.
\itemize{
\item{If \code{data.table}:}{
It should contain the raw curve observations in at least three columns.
\itemize{
\item{\code{idcol} :}{ The name of the column containing the curve index in the sample.
Each curve index is repeated according to the number of observation points.}
\item{\code{tcol} :}{ The name of the column with observation points associated with each curve index.}
\item{\code{ycol} :}{ The name of the column with observed values at each observation point for each curve index.}
}
}
\item{If \code{list} of \code{data.table}:}{
In this case, each element in the \code{list} represents the observation data of a curve in the form of a \code{data.table} or \code{data.frame}.
Each \code{data.table} contains at least two columns.
\itemize{
\item{\code{tcol} :}{ The name of the column with observation points for the curve.}
\item{\code{ycol} :}{ The name of the column with observed values for the curve.}
}
}
\item{If \code{list} of \code{list}:}{
In this case, \code{data} is a list where each element is the observation data of a curve, given as a \code{list} of two vectors.
\itemize{
\item{\code{tcol} :}{ The vector containing observation points for the curve.}
\item{\code{ycol} :}{ The vector containing observed values for the curve.}
}
}
}}

\item{idcol}{\code{character}. If \code{data} is given as a \code{data.table} or \code{data.frame}, this is the name of the column that holds the curve index.
Each curve index is repeated according to the number of observation points. If \code{data} is a \code{list} of \code{data.table} (or \code{data.frame}) or a \code{list} of \code{list}, set \code{idcol = NULL}.}

\item{tcol}{\code{character}. The name of the column (or vector) containing the observation points for the curves.}

\item{ycol}{\code{character}. The name of the column with observed values for the curves.}

\item{Kfold}{\code{integer (positive)}. Number of fold for the cross-validation.}

\item{bw_grid}{\code{vector (numeric)}. The bandwidth grid.}

\item{smooth_ker}{\code{function}. The kernel function of the Nadaraya-Watson estimator. Default \code{smooth_ker = kernel_epanechnikov}.}
}
\value{
A \code{data.table} containing the following columns.
\itemize{
\item{h :}{ The candidate bandwidth.}
\item{cv_error :}{ The estimates of the Cross-Validation error for each \code{h}.}
}
}
\description{
Bandwidth estimation using cross-validation for the \insertCite{rubin2020;textual}{adaptiveFTS} mean function estimator.
}
\examples{
\dontrun{
# Generate a FAR A process
dt_far <- simulate_far(N = 50, lambda = 70,
                       tdesign = "random",
                       Mdistribution = rpois,
                       tdistribution = runif,
                       tcommon = NULL,
                       hurst_fun = hurst_logistic,
                       L = 4,
                       far_kernel = get_real_data_far_kenel,
                       far_mean = get_real_data_mean,
                       int_grid = 100L,
                       burnin = 100L,
                       remove_burnin = TRUE)

# Add noise
dt_far[, X := X + rnorm(n = .N, mean = 0, sd = 0.9 ** (0.1)), by = id_curve]

## Estimate the bandwidth by Cross-Validation
dt_bw_mean_rp <- estimate_mean_bw_rp(
  data = dt_far, idcol = "id_curve", tcol = "tobs", ycol = "X",
  Kfold = 10, bw_grid = seq(0.001, 0.15, len = 45),
  smooth_ker = epanechnikov)

## Plot the Cross-Validation error
dygraphs::dygraph(dt_bw_mean_rp)

## Select the best bandwidth
optbw <- dt_bw_mean_rp[, h[which.min(cv_error)]]

## Estimate the mean function
dt_mean_rp <- estimate_mean_rp(
  data = dt_far, idcol = "id_curve", tcol = "tobs", ycol = "X",
  t = c(1/4, 1/2, 3/4), h = optbw, smooth_ker = kernel_epanechnikov)

DT::datatable(data = dt_mean_rp[, lapply(.SD, function(X) round(X, 5))])

}

}
\references{
\insertAllcited{}
}
\seealso{
\code{\link[=estimate_mean_rp]{estimate_mean_rp()}}
}
