% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/04_estimate_mean.R
\name{estimate_mean}
\alias{estimate_mean}
\title{Estimate Mean Function}
\usage{
estimate_mean(
  data,
  idcol = "id_curve",
  tcol = "tobs",
  ycol = "X",
  t = c(1/4, 1/2, 3/4),
  optbw = NULL,
  bw_grid = NULL,
  kernel_name = "epanechnikov"
)
}
\arguments{
\item{data}{A \code{data.table} (or \code{data.frame}), a \code{list} of \code{data.table} (or \code{data.frame}), or a \code{list} of \code{list}.
\itemize{
\item{If \code{data.table}:}{
It should contain the raw curve observations in at least three columns.
\itemize{
\item{\code{idcol} :}{ The name of the column containing the curve index in the sample.
Each curve index is repeated according to the number of observation points.}
\item{\code{tcol} :}{ The name of the column with observation points associated with each curve index.}
\item{\code{ycol} :}{ The name of the column with observed values at each observation point for each curve index.}
}
}
\item{If \code{list} of \code{data.table}:}{
In this case, each element in the \code{list} represents the observation data of a curve in the form of a \code{data.table} or \code{data.frame}.
Each \code{data.table} contains at least two columns.
\itemize{
\item{\code{tcol} :}{ The name of the column with observation points for the curve.}
\item{\code{ycol} :}{ The name of the column with observed values for the curve.}
}
}
\item{If \code{list} of \code{list}:}{
In this case, \code{data} is a list where each element is the observation data of a curve, given as a \code{list} of two vectors.
\itemize{
\item{\code{tcol} :}{ The vector containing observation points for the curve.}
\item{\code{ycol} :}{ The vector containing observed values for the curve.}
}
}
}}

\item{idcol}{\code{character}. If \code{data} is given as a \code{data.table} or \code{data.frame}, this is the name of the column that holds the curve index.
Each curve index is repeated according to the number of observation points. If \code{data} is a \code{list} of \code{data.table} (or \code{data.frame}) or a \code{list} of \code{list}, set \code{idcol = NULL}.}

\item{tcol}{\code{character}. The name of the column (or vector) containing the observation points for the curves.}

\item{ycol}{\code{character}. The name of the column with observed values for the curves.}

\item{t}{\code{vector (numeric)}. Observation points where the mean function of the underlying process is estimated.}

\item{optbw}{\code{vector (numeric)}. Optimal bandwidth parameters for mean function estimation at each \code{t}.
If \code{optbw = NULL} (default), it will be estimated using the \link{estimate_mean_risk} function.}

\item{bw_grid}{\code{vector (numeric)}. A bandwidth grid from which the best smoothing parameter is selected for each \code{t}.
Default is \code{NULL}, in which case it is defined as an exponential grid of \eqn{N \lambda}.}

\item{kernel_name}{\code{string}. Specifies the kernel function for estimation; default is "epanechnikov".
Supported kernels include: "epanechnikov", "biweight", "triweight", "tricube", "triangular", and "uniform".}
}
\value{
A \code{data.table} containing the following columns:
\itemize{
\item{\code{t} :}{ The observation points at which the mean function is estimated.}
\item{\code{optbw} :}{ The optimal bandwidth used to estimate the mean function at each \code{t}.}
\item{\code{Ht} :}{ Local exponent estimates for each \code{t}, corresponding to \eqn{H_t}.}
\item{\code{Lt} :}{ Estimates of the HÃ¶lder constant for each \code{t}, corresponding to \eqn{L_t^2}.}
\item{\code{PN} :}{ The number of selected curves used in the estimation for each \code{t}.}
\item{\code{muhat} :}{ Estimated values of the mean function at each \code{t}.}
}
}
\description{
This function estimates the mean function of an underlying process using the adaptive estimator described in
\insertCite{maissoro2024adaptive;textual}{adaptiveFTS}.
}
\examples{
\dontrun{
# Load data
data("data_far")

# Estimate risk function for the mean
dt_mean_risk <- estimate_mean_risk(
  data = data_far, idcol = "id_curve", tcol = "tobs", ycol = "X",
  t = c(1/4, 1/2, 3/4), bw_grid = NULL,
  kernel_name = "epanechnikov"
)

# Visualize mean risk at various observation points
dt_dcast <- data.table::dcast(data = dt_mean_risk, formula = h ~ t, value.var = "mean_risk")
manipulateWidget::combineWidgets(
  list = list(
    dygraphs::dygraph(
      data = dt_dcast[, list(h, "t = 0.25" = `0.25`)],
      main = "t = 0.25", xlab = "h", ylab = "Risk Function"),
    dygraphs::dygraph(
      data = dt_dcast[, list(h, "t = 0.5" = `0.5`)],
      main = "t = 0.5", xlab = "h", ylab = "Risk Function"),
    dygraphs::dygraph(
      data = dt_dcast[, list(h, "t = 0.75" = `0.75`)],
      main = "t = 0.75", xlab = "h", ylab = "Risk Function")
  ),
  nrow = 3
)

# Estimate mean function with optimal bandwidths
dt_mean <- estimate_mean(
  data = data_far, idcol = "id_curve", tcol = "tobs", ycol = "X",
  t = c(1/4, 1/2, 3/4), bw_grid = seq(0.005, 0.15, len = 45),
  kernel_name = "epanechnikov"
)

# Display rounded estimates of the mean function
DT::datatable(data = dt_mean[, lapply(.SD, function(X) round(X, 3))])
}

}
\references{
\insertAllCited{}
}
\seealso{
\code{\link[=estimate_mean_risk]{estimate_mean_risk()}}, \code{\link[=estimate_locreg]{estimate_locreg()}}, \code{\link[=estimate_sigma]{estimate_sigma()}}, \code{\link[=estimate_nw]{estimate_nw()}}, \code{\link[=estimate_empirical_autocov]{estimate_empirical_autocov()}}.
}
