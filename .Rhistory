)
return(dt_res)
}, h = h, s = s, t = t, Hs = Hs, Ht = Ht, kernel_smooth = kernel_smooth, data = data))
# Split and merge by lag
## The argument s is associated to the curves n = 1,..., N-lag
dt_risk_s <- dt_risk[, list(id_curve, s, t, wmax_s, cn_s, bn2H_s, pin_s)]
dt_risk_s <- dt_risk_s[id_curve %in% 1:(N - lag)]
dt_id_lag_s <- data.table::data.table(
"id_curve" = sort(unique(dt_risk_s[, id_curve])),
"id_lag" = paste0(1:(N - lag), "_", (1 + lag):N))
dt_risk_s <- data.table::merge.data.table(
x = dt_id_lag_s,
y = dt_risk_s,
by = "id_curve")
## The argument t is associated to the curves n = 1 + lag,..., N
dt_risk_t <- dt_risk[, list(id_curve, s, t, wmax_t, cn_t, bn2H_t, pin_t)]
dt_risk_t <- dt_risk_t[id_curve %in% (1 + lag):N]
dt_id_lag_t <- data.table::data.table(
"id_curve" = sort(unique(dt_risk_t[, id_curve])),
"id_lag" = paste0(1:(N - lag), "_", (1 + lag):N))
dt_risk_t <- data.table::merge.data.table(
x = dt_id_lag_t,
y = dt_risk_t,
by = "id_curve")
dt_risk_merge <- data.table::merge.data.table(
x = dt_risk_s,
y = dt_risk_t,
by = c("id_lag", "s", "t"))
dt_risk_merge <- dt_risk_merge[order(id_curve.x)]
## Clean unnecessary object
rm(dt_id_lag_s, dt_id_lag_t, dt_risk_s, dt_risk_t, dt_risk)
gc()
gc()
# Compute P_N(s, t; h)
dt_risk_merge[, PNl := sum(pin_s * pin_t), by = c("s", "t")]
# compute \mathbb B(s|t,h, 2H_s, 0) and \mathbb B(t|s,h, 2H_t, \ell)
dt_risk_merge[, Bs := sum(pin_s * pin_t * cn_s * bn2H_s) / PNl, by = c("s", "t")]
dt_risk_merge[, Bt := sum(pin_s * pin_t * cn_t * bn2H_t) / PNl, by = c("s", "t")]
# Compute \mathbb V_{\gamma, 1}(s, t; h) and \mathbb V_{\gamma, 2}(s, t; h)
dt_risk_merge[, Vgamma1 := sum(pin_s * pin_t * cn_s * wmax_s) / PNl ** 2, by = c("s", "t")]
dt_risk_merge[, Vgamma2 := sum(pin_s * pin_t * cn_t * wmax_t) / PNl ** 2, by = c("s", "t")]
dt_risk_merge[, Vgamma := sum(pin_s * pin_t * cn_s * cn_t * wmax_s * wmax_t) / PNl ** 2, by = c("s", "t")]
dt_var_s
dt_var_t
data.table::setnames(x = dt_var_s, old = "t", "s")
# Compute P_N(s, t; h)
dt_risk_merge[, PNl := sum(pin_s * pin_t), by = c("s", "t")]
dt_id_lag_s
dt_risk_merge
# compute \mathbb B(s|t,h, 2H_s, 0) and \mathbb B(t|s,h, 2H_t, \ell)
dt_risk_merge[, Bs := sum(pin_s * pin_t * cn_s * bn2H_s) / PNl, by = c("s", "t")]
dt_risk_merge[, Bt := sum(pin_s * pin_t * cn_t * bn2H_t) / PNl, by = c("s", "t")]
# Compute \mathbb V_{\gamma, 1}(s, t; h) and \mathbb V_{\gamma, 2}(s, t; h)
dt_risk_merge[, Vgamma1 := sum(pin_s * pin_t * cn_s * wmax_s) / PNl ** 2, by = c("s", "t")]
dt_risk_merge[, Vgamma2 := sum(pin_s * pin_t * cn_t * wmax_t) / PNl ** 2, by = c("s", "t")]
dt_risk_merge[, Vgamma := sum(pin_s * pin_t * cn_s * cn_t * wmax_s * wmax_t) / PNl ** 2, by = c("s", "t")]
# Compute the risk for each h
dt_risk <- unique(dt_risk_merge[, list(s, t, Bs, Bt, Vgamma1, Vgamma2, Vgamma, PNl)])
dt_risk
dt_var_s
data.table::setnames(x = dt_var_s, old = c("t", "autocov"), new = c("s", "var_s"))
# Estimation of the variance using the presmoothing bandwidth
dt_var_s <- estimate_empirical_autocov(
data = data, idcol = "id_curve",
tcol = "tobs", ycol = "X", t = s, lag = 0,
h = dt_locreg_s[, unique(h)],
smooth_ker = smooth_ker)
data.table::setnames(x = dt_var_s, old = c("t", "autocov"), new = c("s", "var_s"))
dt_var_s
# Estimation of the variance using the presmoothing bandwidth
dt_var_s <- estimate_empirical_autocov(
data = data, idcol = "id_curve",
tcol = "tobs", ycol = "X", t = s, lag = 0,
h = dt_locreg_s[, unique(h)],
smooth_ker = smooth_ker)
data.table::setnames(x = dt_var_s, old = c("t", "autocov"), new = c("s", "var_s"))
dt_var_t <- estimate_empirical_autocov(
data = data, idcol = "id_curve",
tcol = "tobs", ycol = "X", t = t, lag = 0,
h = dt_locreg_s[, unique(h)],
smooth_ker = smooth_ker)
data.table::setnames(x = dt_var_t, old = "autocov", new = "var_t")
dt_var_t <- estimate_empirical_autocov(
data = data, idcol = "id_curve",
tcol = "tobs", ycol = "X", t = t, lag = 0,
h = dt_locreg_s[, unique(h)],
smooth_ker = smooth_ker)
data.table::setnames(x = dt_var_t, old = "autocov", new = "var_t")
dt_var <- cbind(
dt_var_s[, list(s, var_s)],
dt_var_t[, list(t, var_t)],
)
dt_var <- cbind(
dt_var_s[, list(s, var_s)],
dt_var_t[, list(t, var_t)]
)
dt_var
gc()
rm(dt_var_s, dt_var_t)
gc()
dt_risk
# Extract the elements by (s,t)
dt_risk <- unique(dt_risk_merge[, list(s, t, Bs, Bt, Vgamma1, Vgamma2, Vgamma, PNl)])
# Add Variance
dt_risk <- data.table::merge.data.table(x = dt_risk, y = dt_var, by = c("s", "t"))
dt_risk
dt_risk[order(s,t)]
dt_risk <- dt_risk[order(s,t)]
## Biais term
bias_term <- 3 * dt_risk[, var_t] * Ls * (h ** (2 * Hs)) * dt_rk[, Bs] +
3 * dt_risk[, var_s] * Lt * (h ** (2 * Ht)) * dt_rk[, Bt]
## Biais term
bias_term <- 3 * dt_risk[, var_t] * Ls * (h ** (2 * Hs)) * dt_risk[, Bs] +
3 * dt_risk[, var_s] * Lt * (h ** (2 * Ht)) * dt_risk[, Bt]
bias_term
N
presmooth_bw = dt_locreg_s[, unique(h)]
kernel_smooth = smooth_ker
data
curve_index
data[id_curve %in% curve_index][order(tobs)]
data[id_curve %in% curve_index][order(tobs), tobs]
data[id_curve %in% curve_index][order(tobs), X]
data[id_curve %in% curve_index][order(tobs), tobs]
s
presmooth_bw_s = dt_locreg_s[, unique(h)]
Xhat_s <- estimate_nw(
y = data[id_curve %in% curve_index][order(tobs), X],
t = data[id_curve %in% curve_index][order(tobs), tobs],
tnew = s,
h = presmooth_bw_s,
smooth_ker = kernel_smooth)
Xhat_s
Xhat_s <- estimate_nw(
y = data[id_curve %in% curve_index][order(tobs), X],
t = data[id_curve %in% curve_index][order(tobs), tobs],
tnew = s,
h = presmooth_bw_s,
smooth_ker = kernel_smooth)
Xhat_s <- Xhat_s[, yhat]
Xhat_s
Xhat_t <- estimate_nw(
y = data[id_curve %in% curve_index][order(tobs), X],
t = data[id_curve %in% curve_index][order(tobs), tobs],
tnew = t,
h = presmooth_bw_t,
smooth_ker = kernel_smooth)
Xhat_t <- Xhat_t[, yhat]
presmooth_bw_t = dt_locreg_t[, unique(h)]
Xhat_t <- estimate_nw(
y = data[id_curve %in% curve_index][order(tobs), X],
t = data[id_curve %in% curve_index][order(tobs), tobs],
tnew = t,
h = presmooth_bw_t,
smooth_ker = kernel_smooth)
Xhat_t
# Estimation of the secon order moment using the presmoothing bandwidth
dt_Xhat <- data.table::rbindlist(
lapply(1:N, function(curve_index, s, t, data, presmooth_bw_s, presmooth_bw_t, kernel_smooth){
Xhat_s <- estimate_nw(
y = data[id_curve %in% curve_index][order(tobs), X],
t = data[id_curve %in% curve_index][order(tobs), tobs],
tnew = s,
h = presmooth_bw_s,
smooth_ker = kernel_smooth)
Xhat_s <- Xhat_s[, yhat]
Xhat_t <- estimate_nw(
y = data[id_curve %in% curve_index][order(tobs), X],
t = data[id_curve %in% curve_index][order(tobs), tobs],
tnew = t,
h = presmooth_bw_t,
smooth_ker = kernel_smooth)
Xhat_t <- Xhat_t[, yhat]
dt_res <- data.table::data.table("id_curve" = curve_index, "s" = s, "t" = t, "Xhat_s" = Xhat_s, "Xhat_t" = Xhat_t)
}, s = s, t = t, kernel_smooth = smooth_ker,
presmooth_bw_s = dt_locreg_s[, unique(h)],
presmooth_bw_t = dt_locreg_t[, unique(h)]))
# Estimation of the secon order moment using the presmoothing bandwidth
dt_Xhat <- data.table::rbindlist(
lapply(1:N, function(curve_index, s, t, presmooth_bw_s, presmooth_bw_t, kernel_smooth, data){
Xhat_s <- estimate_nw(
y = data[id_curve %in% curve_index][order(tobs), X],
t = data[id_curve %in% curve_index][order(tobs), tobs],
tnew = s,
h = presmooth_bw_s,
smooth_ker = kernel_smooth)
Xhat_s <- Xhat_s[, yhat]
Xhat_t <- estimate_nw(
y = data[id_curve %in% curve_index][order(tobs), X],
t = data[id_curve %in% curve_index][order(tobs), tobs],
tnew = t,
h = presmooth_bw_t,
smooth_ker = kernel_smooth)
Xhat_t <- Xhat_t[, yhat]
dt_res <- data.table::data.table("id_curve" = curve_index, "s" = s, "t" = t, "Xhat_s" = Xhat_s, "Xhat_t" = Xhat_t)
}, s = s, t = t,
presmooth_bw_s = dt_locreg_s[, unique(h)],
presmooth_bw_t = dt_locreg_t[, unique(h)],
kernel_smooth = smooth_ker, data = data))
dt_Xhat
dt_Xhat
##  Transform NaN to NA
dt_Xhat[is.nan(Xhat_s), Xhat_s := NA]
dt_Xhat
dt_Xhat[is.nan(Xhat_t), Xhat_t := NA]
dt_Xhat
dt_Xhat[, list("EX2_s" = mean(Xhat_s), "EX2_t" = mean(Xhat_t))]
dt_moment2 <- dt_Xhat[, list("EX2_s" = mean(Xhat_s, na.rm = TRUE), "EX2_t" = mean(Xhat_t, na.rm = TRUE)),
by = c("s", "t")]
dt_moment2
dt_moment2
dt_Exp2
dt_Exp2 <- dt_Xhat[, list("EX2_s" = mean(Xhat_s, na.rm = TRUE), "EX2_t" = mean(Xhat_t, na.rm = TRUE)),
by = c("s", "t")]
dt_Exp2
rm(dt_Xhat)
gc()
dt_EX2 <- dt_Xhat[, list("EX2_s" = mean(Xhat_s, na.rm = TRUE), "EX2_t" = mean(Xhat_t, na.rm = TRUE)),
by = c("s", "t")]
# Estimation of the secon order moment using the presmoothing bandwidth
## Smooth curves at s and at t
dt_Xhat <- data.table::rbindlist(
lapply(1:N, function(curve_index, s, t, presmooth_bw_s, presmooth_bw_t, kernel_smooth, data){
Xhat_s <- estimate_nw(
y = data[id_curve %in% curve_index][order(tobs), X],
t = data[id_curve %in% curve_index][order(tobs), tobs],
tnew = s,
h = presmooth_bw_s,
smooth_ker = kernel_smooth)
Xhat_s <- Xhat_s[, yhat]
Xhat_t <- estimate_nw(
y = data[id_curve %in% curve_index][order(tobs), X],
t = data[id_curve %in% curve_index][order(tobs), tobs],
tnew = t,
h = presmooth_bw_t,
smooth_ker = kernel_smooth)
Xhat_t <- Xhat_t[, yhat]
dt_res <- data.table::data.table("id_curve" = curve_index, "s" = s, "t" = t, "Xhat_s" = Xhat_s, "Xhat_t" = Xhat_t)
}, s = s, t = t,
presmooth_bw_s = dt_locreg_s[, unique(h)],
presmooth_bw_t = dt_locreg_t[, unique(h)],
kernel_smooth = smooth_ker, data = data))
##  Transform NaN to NA
dt_Xhat[is.nan(Xhat_s), Xhat_s := NA]
dt_Xhat[is.nan(Xhat_t), Xhat_t := NA]
dt_EX2 <- dt_Xhat[, list("EX2_s" = mean(Xhat_s, na.rm = TRUE), "EX2_t" = mean(Xhat_t, na.rm = TRUE)),
by = c("s", "t")]
dt_EX2
dt_EX2
# Add second order moment
dt_risk <- data.table::merge.data.table(x = dt_risk, y = dt_EX2, by = c("s", "t"))
# compute quantities to estimate estimate the risk
dt_risk <- data.table::rbindlist(lapply(1:N, function(curve_index, h, s, t, Hs, Ls, Ht, Lt, kernel_smooth, data){
# Extract the observation points per curve
# and compute the weight of the estimator
## By convention NaN = 0
Tn <- data[id_curve == curve_index, tobs]
## For the argument s
ker_s <- outer(X = s, Y = Tn, FUN = function(si, Tnm, Ker) Ker((Tnm - si) / h), Ker = kernel_smooth)
wker_s <- apply(ker_s, 1, function(r) r / ifelse(sum(r) != 0, sum(r), 1))
wker_s <- t(wker_s)
### Take the maximum and c_n(s,h), the sum of the weight
wmax_s <- apply(wker_s, 1, max)
cn_s <- apply(wker_s, 1, function(r) sum(abs(r)))
Tn_s_2H_s <- outer(
X = 1:length(s), Y = Tn,
FUN = function(sid, Tnm, s, Hs) abs((Tnm - s[sid]) / h) ** (2 * Hs[sid]),
s = s, Hs = Hs
)
bn2H_s <- diag(abs(wker_s) %*% t(Tn_s_2H_s))
### \pi_n(s;h)
pin_s <- outer(X = s, Y = Tn, FUN = function(si, Tnm, h) as.numeric(abs(Tnm - si) <= h), h = h)
pin_s <- as.numeric(rowSums(pin_s) >= 1)
## For argument t
### By convention NaN = 0
ker_t <- outer(X = t, Y = Tn, FUN = function(ti, Tnm, Ker) Ker((Tnm - ti) / h), Ker = kernel_smooth)
wker_t <- apply(ker_t, 1, function(r) r / ifelse(sum(r) != 0, sum(r), 1))
wker_t <- t(wker_t)
### Take the maximum and c_n(t,h), the sum of the weight
wmax_t <- apply(wker_t, 1, max)
cn_t <- apply(wker_t, 1, function(r) sum(abs(r)))
Tn_t_2H_t <- outer(
X = 1:length(t), Y = Tn,
FUN = function(tid, Tnm, t, Ht) abs((Tnm - t[tid]) / h) ** (2 * Ht[tid]),
t = t, Ht = Ht
)
bn2H_t <- diag(abs(wker_t) %*% t(Tn_t_2H_t))
# \pi_n(t;h)
pin_t <- outer(X = t, Y = Tn, FUN = function(ti, Tnm, h) as.numeric(abs(Tnm - ti) <= h), h = h)
pin_t <- as.numeric(rowSums(pin_t) >= 1)
# data.table return
dt_res <- data.table::data.table(
"id_curve" = curve_index, "s" = s, "t" = t,
"wmax_s" = wmax_s, "wmax_t" = wmax_t,
"cn_s" = cn_s, "cn_t" = cn_t,
"bn2H_s" = bn2H_s, "bn2H_t" = bn2H_t,
"pin_s" = pin_s, "pin_t" = pin_t
)
return(dt_res)
}, h = h, s = s, t = t, Hs = Hs, Ht = Ht, kernel_smooth = kernel_smooth, data = data))
# Split and merge by lag
## The argument s is associated to the curves n = 1,..., N-lag
dt_risk_s <- dt_risk[, list(id_curve, s, t, wmax_s, cn_s, bn2H_s, pin_s)]
dt_risk_s <- dt_risk_s[id_curve %in% 1:(N - lag)]
dt_id_lag_s <- data.table::data.table(
"id_curve" = sort(unique(dt_risk_s[, id_curve])),
"id_lag" = paste0(1:(N - lag), "_", (1 + lag):N))
dt_risk_s <- data.table::merge.data.table(
x = dt_id_lag_s,
y = dt_risk_s,
by = "id_curve")
## The argument t is associated to the curves n = 1 + lag,..., N
dt_risk_t <- dt_risk[, list(id_curve, s, t, wmax_t, cn_t, bn2H_t, pin_t)]
dt_risk_t <- dt_risk_t[id_curve %in% (1 + lag):N]
dt_id_lag_t <- data.table::data.table(
"id_curve" = sort(unique(dt_risk_t[, id_curve])),
"id_lag" = paste0(1:(N - lag), "_", (1 + lag):N))
dt_risk_t <- data.table::merge.data.table(
x = dt_id_lag_t,
y = dt_risk_t,
by = "id_curve")
dt_risk_merge <- data.table::merge.data.table(
x = dt_risk_s,
y = dt_risk_t,
by = c("id_lag", "s", "t"))
dt_risk_merge <- dt_risk_merge[order(id_curve.x)]
## Clean unnecessary object
rm(dt_id_lag_s, dt_id_lag_t, dt_risk_s, dt_risk_t, dt_risk)
gc()
# Compute P_N(s, t; h)
dt_risk_merge[, PNl := sum(pin_s * pin_t), by = c("s", "t")]
# compute \mathbb B(s|t,h, 2H_s, 0) and \mathbb B(t|s,h, 2H_t, \ell)
dt_risk_merge[, Bs := sum(pin_s * pin_t * cn_s * bn2H_s) / PNl, by = c("s", "t")]
dt_risk_merge[, Bt := sum(pin_s * pin_t * cn_t * bn2H_t) / PNl, by = c("s", "t")]
# Compute \mathbb V_{\gamma, 1}(s, t; h) and \mathbb V_{\gamma, 2}(s, t; h)
dt_risk_merge[, Vgamma1 := sum(pin_s * pin_t * cn_s * wmax_s) / PNl ** 2, by = c("s", "t")]
dt_risk_merge[, Vgamma2 := sum(pin_s * pin_t * cn_t * wmax_t) / PNl ** 2, by = c("s", "t")]
dt_risk_merge[, Vgamma := sum(pin_s * pin_t * cn_s * cn_t * wmax_s * wmax_t) / PNl ** 2, by = c("s", "t")]
# Extract the elements by (s,t)
dt_risk <- unique(dt_risk_merge[, list(s, t, Bs, Bt, Vgamma1, Vgamma2, Vgamma, PNl)])
dt_risk
# Add second order moment
dt_risk <- data.table::merge.data.table(x = dt_risk, y = dt_EX2, by = c("s", "t"))
dt_risk <- dt_risk[order(s,t)]
dt_risk
## Biais term
bias_term <- 3 * dt_risk[, EX2_t] * Ls * (h ** (2 * Hs)) * dt_risk[, Bs] +
3 * dt_risk[, EX2_s] * Lt * (h ** (2 * Ht)) * dt_risk[, Bt]
bias_term
dt_risk[, Bt]
Lt * (h ** (2 * Ht))
Lt
Ls
(h ** (2 * Hs))
## Biais term
bias_term <- 3 * dt_risk[, EX2_t] * Ls * (h ** (2 * Hs)) * dt_risk[, Bs] +
3 * dt_risk[, EX2_s] * Lt * (h ** (2 * Ht)) * dt_risk[, Bt]
bias_term
dt_sigma_s
dt_sigma_s
dt_sigma_s[, list("s" = "t", "sig_error_s" = sig)]
dt_sigma <- cbind(
dt_sigma_s[, list("s" = t, "sig_error_s" = sig)],
dt_sigma_t[, list("t" = "t", "sig_error_s" = sig)]
)
dt_sigma <- cbind(
dt_sigma_s[, list("s" = t, "sig_error_s" = sig)],
dt_sigma_t[, list("t" = t, "sig_error_t" = sig)]
)
dt_sigma
rm(dt_sigma_s, dt_sigma_t)
dt_sigma_s
dt_sigma
dt_sigma
dt_risk <- data.table::merge.data.table(x = dt_risk, y = dt_sigma, by = c("s", "t"))
dt_risk
dt_risk <- dt_risk[order(s,t)]
dt_risk
3 * dt_risk[, sig_error_s] * dt_risk[, EX2_t] * dt_risk[, Vgamma1] +
3 * dt_risk[, sig_error_t] * dt_risk[, EX2_s] * dt_risk[, Vgamma2] +
3 * dt_risk[, sig_error_s] * dt_risk[, sig_error_t] * dt_risk[, Vgamma]
## Variance term
varriance_term <- 3 * dt_risk[, sig_error_s] * dt_risk[, EX2_t] * dt_risk[, Vgamma1] +
3 * dt_risk[, sig_error_t] * dt_risk[, EX2_s] * dt_risk[, Vgamma2] +
3 * dt_risk[, sig_error_s] * dt_risk[, sig_error_t] * dt_risk[, Vgamma]
git status
dt_risk
dt_risk_merge
# Sort by s and t
dt_st <- data.table::data.table("s" = s, "t" = t)
dt_st
dt_st[order(s,t)]
# Sort by s and t
dt_st <- data.table::data.table("s" = s, "t" = t)
dt_st <- dt_st[order(s,t)]
s <- dt_st[, s]
t <- dt_st[, t]
# Sort by s and t
dt_st <- data.table::data.table("s" = s, "t" = t)
dt_st <- dt_st[order(s,t)]
s <- dt_st[, s]
t <- dt_st[, t]
rm(dt_st)
gc()
dt_risk_merge
1:length(s)
sid <- 1
sid
dt_rho_ell[s == s[sid] & t == t[sid], PNl]
dt_risk_merge
## Dependence term
### Compute \rho_k(s,t;h)
dt_rho_ell <- unique(dt_risk_merge[, list(id_curve.x, id_curve.y, id_lag, s, t, pin_s, pin_t, PNl)])
dt_rho_ell
lag
# Sort by s and t
dt_st <- data.table::data.table("s" = s, "t" = t)
dt_st <- dt_st[order(s,t)]
s <- dt_st[, s]
t <- dt_st[, t]
rm(dt_st)
gc()
dt_Xhat
rm(dt_Xhat)
gc()
## Convergence term to true mean
### Compute \rho_\ell(t;h)
dt_rho_ell <- unique(dt_risk_merge[, list(id_curve.x, id_curve.y, id_lag, s, t, pin_s, pin_t, PNl)])
## Convergence term to true mean
### Compute \rho_\ell(t;h)
dt_rho_k <- unique(dt_risk_merge[, list(id_curve.x, id_curve.y, id_lag, s, t, pin_s, pin_t, PNl)])
## Convergence term to true mean
### Compute p_k(s,t;h)
dt_p_k <- unique(dt_risk_merge[, list(id_curve.x, id_curve.y, id_lag, s, t, pin_s, pin_t, PNl)])
dt_p_k
PN <- unique(dt_p_k[s == s[sid] & t == t[sid], PN])
PN <- unique(dt_p_k[s == s[sid] & t == t[sid], PNl])
PN
pin_s_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.x), pin_s]
pin_s_vec
PNl <- unique(dt_p_k[s == s[sid] & t == t[sid], PNl])
PNl
pin_s_vec
PNl <- unique(dt_p_k[s == s[sid] & t == t[sid], PNl])
pin_s_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.x), pin_s]
pin_s_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.x), pin_s]
pin_s_i <- pin_s_vec[1:((N - lag) - k )]
pin_s_i_plus_k <- pin_s_vec[(1 + k):(N - lag)]
k <- 3
PNl <- unique(dt_p_k[s == s[sid] & t == t[sid], PNl])
PNl
# Compute \pi_i(s; h) and \pi_{i + k}(t; h)
pin_s_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.x), pin_s]
pin_s_vec
pin_s_i <- pin_s_vec[1:((N - lag) - k )]
pin_s_i_plus_k <- pin_s_vec[(1 + k):(N - lag)]
# Compute \pi_{i + \ell}}(t; h) and \pi_{i + \ell + k}(t;h)
pin_t_plus_ell_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.y), pin_t]
pin_t_plus_ell_vec
# Compute \pi_{i + \ell}}(t; h) and \pi_{i + \ell + k}(t;h)
pin_t_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.y), pin_t]
# Compute \pi_{i + \ell}}(t; h) and \pi_{i + \ell + k}(t;h)
pin_t_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.y), pin_t]
pin_t_i_plus_ell <- pin_t_vec[1:((N - lag) - k)]
pin_t_i_plus_ell_plus_k <- pin_t_vec[(1 + k):(N - lag)]
pin_t_vec
pin_t_i_plus_ell
pin_t_i_plus_ell_plus_k
p_k
p_k <- sum((pin_s_i * pin_t_i_plus_ell) * (pin_s_i_plus_k * pin_t_i_plus_ell_plus_k)) / PNl
p_k
## Convergence term to true mean
### Compute p_k(s,t;h)
dt_p_k <- unique(dt_risk_merge[, list(id_curve.x, id_curve.y, id_lag, s, t, pin_s, pin_t, PNl)])
dt_p <- data.table::rbindlist(lapply(1:(N-lag), function(k, s, t, dt_p_k){
data.table::rbindlist(lapply(1:length(s), function(sid, k, s, t, dt_p_k){
PNl <- unique(dt_p_k[s == s[sid] & t == t[sid], PNl])
# Compute \pi_i(s; h) and \pi_{i + k}(t; h)
pin_s_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.x), pin_s]
pin_s_i <- pin_s_vec[1:((N - lag) - k )]
pin_s_i_plus_k <- pin_s_vec[(1 + k):(N - lag)]
# Compute \pi_{i + \ell}}(t; h) and \pi_{i + \ell + k}(t;h)
pin_t_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.y), pin_t]
pin_t_i_plus_ell <- pin_t_vec[1:((N - lag) - k)]
pin_t_i_plus_ell_plus_k <- pin_t_vec[(1 + k):(N - lag)]
p_k <- sum((pin_s_i * pin_t_i_plus_ell) * (pin_s_i_plus_k * pin_t_i_plus_ell_plus_k)) / PNl
dt_res <- data.table::data.table("s" = s[sid], "t" = t[sid], "lag" = k, "pk" = p_k)
rm(pin_s_vec, pin_s_i, pin_s_i_plus_k, pin_t_vec, pin_t_i_plus_ell, pin_t_i_plus_ell_plus_k, PNl)
gc()
return(dt_res)
}, k = k, s = s, t = t, dt_p_k = dt_p_k))
}, s = s, t = t, dt_p_k = dt_p_k))
dt_p
dt_p <- data.table::rbindlist(lapply(1:(N-lag - 1), function(k, s, t, dt_p_k){
data.table::rbindlist(lapply(1:length(s), function(sid, k, s, t, dt_p_k){
PNl <- unique(dt_p_k[s == s[sid] & t == t[sid], PNl])
# Compute \pi_i(s; h) and \pi_{i + k}(t; h)
pin_s_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.x), pin_s]
pin_s_i <- pin_s_vec[1:((N - lag) - k )]
pin_s_i_plus_k <- pin_s_vec[(1 + k):(N - lag)]
# Compute \pi_{i + \ell}}(t; h) and \pi_{i + \ell + k}(t;h)
pin_t_vec <- dt_p_k[s == s[sid] & t == t[sid]][order(id_curve.y), pin_t]
pin_t_i_plus_ell <- pin_t_vec[1:((N - lag) - k)]
pin_t_i_plus_ell_plus_k <- pin_t_vec[(1 + k):(N - lag)]
p_k <- sum((pin_s_i * pin_t_i_plus_ell) * (pin_s_i_plus_k * pin_t_i_plus_ell_plus_k)) / PNl
dt_res <- data.table::data.table("s" = s[sid], "t" = t[sid], "lag" = k, "pk" = p_k)
rm(pin_s_vec, pin_s_i, pin_s_i_plus_k, pin_t_vec, pin_t_i_plus_ell, pin_t_i_plus_ell_plus_k, PNl)
gc()
return(dt_res)
}, k = k, s = s, t = t, dt_p_k = dt_p_k))
}, s = s, t = t, dt_p_k = dt_p_k))
dt_p
