far_mean = function(t) 4 * sin(1.5 * pi * t),
int_grid = 100L,
burnin = 100L,
remove_burnin = TRUE) {
if (! is.integer(N) & N > 1)
stop("N' must be an integer greater than 1.")
if (! is.integer(lambda) & lambda > 1)
stop("N' must be an integer greater than 1.")
if (! class(tdesign) == "character"){
stop("'tdesign' must be a character.")
}else{
tdesign <- match.arg(arg = tdesign, choices = c("random", "common"))
}
if (! class(tdistribution) == "function")
stop("'tdistribution' must be a function.")
if (tdesign == "common"){
if (is.null(tcommon) | ! (any(tcommon > 0 & tcommon <= 1) & length(tcommon) > 2))
stop("'tcommon' must be of minimum length 2 with values between 0 and 1.")
}else{
if (! is.null(tcommon) & ! (any(tcommon > 0 & tcommon <= 1) & length(tcommon) > 2))
stop("If tdesign = 'random', 'tcommon' must be either NULL or of minimum length 2 with values between 0 and 1.")
}
if (! class(hurst_fun) == "function")
stop("'hurst_fun' must be a function.")
if (! L > 0)
stop("'L' must be a positive scalar value.")
if (! class(far_kernel) == "function")
stop("'far_kernel' must be bevariate function")
if (! class(far_mean) == "function")
stop("'far_mean' must be a function")
if (! (is.integer(int_grid) & int_grid > 50))
stop("'int_grid' must be an integer greater than 30.")
if (! (is.integer(burnin) & burnin > 30))
stop("'burnin' must be an integer greater than 30.")
if (! class(remove_burnin) == "logical")
stop("'remove_burnin' must be boolean.")
n <- N + burnin
grid <- (1:int_grid) / int_grid
# If random design
if (tdesign == "random"){
dt_rdesign <- .random_design(N = n, lambda = lambda, tdistribution = tdistribution)
M <- dt_rdesign[, .("Mn" = unique(Mn)), by = "id_curve"][, Mn]
dt_far <- data.table::rbindlist(lapply(1:n, function(i, dt_rdesign, grid, tcommon, M, hurst_fun, L){
# Combine design + integration grid + tcommon
tall <- c(dt_rdesign[id_curve == i, Tn], grid, tcommon)
ttag <- c(rep("Tn", M[i]), rep("int_grid", length(grid)), rep("tcommon", length(tcommon)))
dt <- data.table::data.table("id_curve" = i, "tall" = tall, "ttag" = ttag)
dt <- dt[order(tall)]
# Generate and add mfBm
dt_eps <- simulate_mfBm(t = dt[, tall], hurst_fun = hurst_fun, L = L, tied = FALSE)
dt[, eps := dt_eps[, mfBm]]
# Add mean function
dt[, far_mean := far_mean(tall)]
}, dt_rdesign = dt_rdesign, grid = grid, tcommon = tcommon, M = M, hurst_fun = hurst_fun, L = L))
} else {
# Common design case
dt_far <- data.table::rbindlist(lapply(1:n, function(i, tcommon, grid, hurst_fun, L){
# Combine design + integration grid
tall <- c(tcommon, grid)
ttag <- c(rep("tcommon", length(tcommon)), rep("int_grid", length(grid)))
dt <- data.table::data.table("id_curve" = i, "tall" = tall, "ttag" = ttag)
dt <- dt[order(tall)]
# Generate and add mfBm
dt_eps <- simulate_mfBm(t = dt[, tall], hurst_fun = hurst_fun, L = L, tied = FALSE)
dt[, eps := dt_eps[, mfBm]]
# Add mean function
dt[, far_mean := far_mean(tall)]
}, tcommon = tcommon, grid = grid, hurst_fun = hurst_fun, L = L))
}
# Generate FAR(1)
dt_far[id_curve == 1, X := far_mean + eps]
for(i in 2:n){
tall <- dt_far[id_curve == i, tall]
Xold_centred <- dt_far[id_curve == i - 1 & ttag == "int_grid", X - far_mean]
Enew <- dt_far[id_curve == i, eps]
far_mean_new <- dt_far[id_curve == i, far_mean]
tmp <- expand.grid(u = tall, v = grid)
u <- tmp$u
v <- tmp$v
beta <- matrix(far_kernel(u,v), ncol = int_grid, byrow = FALSE)
Xi <- far_mean_new + as.numeric((1/int_grid) * beta %*% matrix(Xold_centred, ncol = 1) + Enew)
dt_far[id_curve == i, X := Xi]
}
if(remove_burnin){
dt_far <- dt_far[! id_curve %in% 1:burnin]
}
X
}
dt_far <- far.sim(N = 2L, lambda = 70L,
tdesign = "random",
tdistribution = runif,
tcommon = seq(0.2, 0.8, len = 50),
hurst_fun = hurst_logistic,
L = 4,
far_kernel = function(s,t) 9/4 * exp( - (t + 2 * s) ** 2),
far_mean = function(t) 4 * sin(1.5 * pi * t),
int_grid = 100L,
burnin = 100L,
remove_burnin = TRUE)
#'
#' @return
#'
#' @importFrom data.table data.table rbindlist
#'
#' @export
#'
#' @examples
#'
#'
far.sim <- function(N = 2L, lambda = 70L,
tdesign = "random",
tdistribution = runif,
tcommon = seq(0.2, 0.8, len = 50),
hurst_fun = hurst_logistic,
L = 4,
far_kernel = function(s,t) 9/4 * exp( - (t + 2 * s) ** 2),
far_mean = function(t) 4 * sin(1.5 * pi * t),
int_grid = 100L,
burnin = 100L,
remove_burnin = TRUE) {
if (! is.integer(N) & N > 1)
stop("N' must be an integer greater than 1.")
if (! is.integer(lambda) & lambda > 1)
stop("N' must be an integer greater than 1.")
if (! class(tdesign) == "character"){
stop("'tdesign' must be a character.")
}else{
tdesign <- match.arg(arg = tdesign, choices = c("random", "common"))
}
if (! class(tdistribution) == "function")
stop("'tdistribution' must be a function.")
if (tdesign == "common"){
if (is.null(tcommon) | ! (any(tcommon > 0 & tcommon <= 1) & length(tcommon) > 2))
stop("'tcommon' must be of minimum length 2 with values between 0 and 1.")
}else{
if (! is.null(tcommon) & ! (any(tcommon > 0 & tcommon <= 1) & length(tcommon) > 2))
stop("If tdesign = 'random', 'tcommon' must be either NULL or of minimum length 2 with values between 0 and 1.")
}
if (! class(hurst_fun) == "function")
stop("'hurst_fun' must be a function.")
if (! L > 0)
stop("'L' must be a positive scalar value.")
if (! class(far_kernel) == "function")
stop("'far_kernel' must be bevariate function")
if (! class(far_mean) == "function")
stop("'far_mean' must be a function")
if (! (is.integer(int_grid) & int_grid > 50))
stop("'int_grid' must be an integer greater than 30.")
if (! (is.integer(burnin) & burnin > 30))
stop("'burnin' must be an integer greater than 30.")
if (! class(remove_burnin) == "logical")
stop("'remove_burnin' must be boolean.")
n <- N + burnin
grid <- (1:int_grid) / int_grid
# If random design
if (tdesign == "random"){
dt_rdesign <- .random_design(N = n, lambda = lambda, tdistribution = tdistribution)
M <- dt_rdesign[, .("Mn" = unique(Mn)), by = "id_curve"][, Mn]
dt_far <- data.table::rbindlist(lapply(1:n, function(i, dt_rdesign, grid, tcommon, M, hurst_fun, L){
# Combine design + integration grid + tcommon
tall <- c(dt_rdesign[id_curve == i, Tn], grid, tcommon)
ttag <- c(rep("Tn", M[i]), rep("int_grid", length(grid)), rep("tcommon", length(tcommon)))
dt <- data.table::data.table("id_curve" = i, "tall" = tall, "ttag" = ttag)
dt <- dt[order(tall)]
# Generate and add mfBm
dt_eps <- simulate_mfBm(t = dt[, tall], hurst_fun = hurst_fun, L = L, tied = FALSE)
dt[, eps := dt_eps[, mfBm]]
# Add mean function
dt[, far_mean := far_mean(tall)]
}, dt_rdesign = dt_rdesign, grid = grid, tcommon = tcommon, M = M, hurst_fun = hurst_fun, L = L))
} else {
# Common design case
dt_far <- data.table::rbindlist(lapply(1:n, function(i, tcommon, grid, hurst_fun, L){
# Combine design + integration grid
tall <- c(tcommon, grid)
ttag <- c(rep("tcommon", length(tcommon)), rep("int_grid", length(grid)))
dt <- data.table::data.table("id_curve" = i, "tall" = tall, "ttag" = ttag)
dt <- dt[order(tall)]
# Generate and add mfBm
dt_eps <- simulate_mfBm(t = dt[, tall], hurst_fun = hurst_fun, L = L, tied = FALSE)
dt[, eps := dt_eps[, mfBm]]
# Add mean function
dt[, far_mean := far_mean(tall)]
}, tcommon = tcommon, grid = grid, hurst_fun = hurst_fun, L = L))
}
# Generate FAR(1)
dt_far[id_curve == 1, X := far_mean + eps]
for(i in 2:n){
tall <- dt_far[id_curve == i, tall]
Xold_centred <- dt_far[id_curve == i - 1 & ttag == "int_grid", X - far_mean]
Enew <- dt_far[id_curve == i, eps]
far_mean_new <- dt_far[id_curve == i, far_mean]
tmp <- expand.grid(u = tall, v = grid)
u <- tmp$u
v <- tmp$v
beta <- matrix(far_kernel(u,v), ncol = int_grid, byrow = FALSE)
Xi <- far_mean_new + as.numeric((1/int_grid) * beta %*% matrix(Xold_centred, ncol = 1) + Enew)
dt_far[id_curve == i, X := Xi]
}
if(remove_burnin){
dt_far <- dt_far[! id_curve %in% 1:burnin]
}
return(dt_far)
}
dt_far <- far.sim(N = 2L, lambda = 70L,
tdesign = "random",
tdistribution = runif,
tcommon = seq(0.2, 0.8, len = 50),
hurst_fun = hurst_logistic,
L = 4,
far_kernel = function(s,t) 9/4 * exp( - (t + 2 * s) ** 2),
far_mean = function(t) 4 * sin(1.5 * pi * t),
int_grid = 100L,
burnin = 100L,
remove_burnin = TRUE)
dt_far
dt_far[, table(ttag)]
dt_far[, table(ttag), by = .N]
dt_far[, table(ttag), by = "id_curve"]
dt_far[, table(ttag)]
dt_far[, table(ttag), by = "id_curve"]
dt_far[ttag == "int_grid"]
dt_far[ttag != "int_grid"]
dt_far
# Remove the data for integral approximation
dt_far <- dt_far[ttag != "int_grid"]
dt_far
burnin <- 100
dt_far[, id_curve := id_curve - burnin]
dt_far
dt_far[, table(dt_far)]
dt_far <- far.sim(N = 2L, lambda = 70L,
tdesign = "random",
tdistribution = runif,
tcommon = NULL,
hurst_fun = hurst_logistic,
L = 4,
far_kernel = function(s,t) 9/4 * exp( - (t + 2 * s) ** 2),
far_mean = function(t) 4 * sin(1.5 * pi * t),
int_grid = 100L,
burnin = 100L,
remove_burnin = TRUE)
dt_far[, table(ttag)]
#'                   hurst_fun = hurst_logistic,
#'                   L = 4,
#'                   far_kernel = function(s,t) 9/4 * exp( - (t + 2 * s) ** 2),
#'                   far_mean = function(t) 4 * sin(1.5 * pi * t),
#'                   int_grid = 100L,
#'                   burnin = 100L,
#'                   remove_burnin = TRUE)
#'
#'}
#'
far.sim <- function(N = 2L, lambda = 70L,
tdesign = "random",
tdistribution = runif,
tcommon = seq(0.2, 0.8, len = 50),
hurst_fun = hurst_logistic,
L = 4,
far_kernel = function(s,t) 9/4 * exp( - (t + 2 * s) ** 2),
far_mean = function(t) 4 * sin(1.5 * pi * t),
int_grid = 100L,
burnin = 100L,
remove_burnin = TRUE) {
if (! is.integer(N) & N > 1)
stop("N' must be an integer greater than 1.")
if (! is.integer(lambda) & lambda > 1)
stop("N' must be an integer greater than 1.")
if (! class(tdesign) == "character"){
stop("'tdesign' must be a character.")
}else{
tdesign <- match.arg(arg = tdesign, choices = c("random", "common"))
}
if (class(tdistribution) != "function" & tdesign == "random")
stop("If tdesign = 'random', then 'tdistribution' must be a function.")
if ((! is.null(tdistribution)) & tdesign == "common")
stop("If tdesign = 'common', then 'tdistribution' must be NULL")
if (tdesign == "common"){
if (is.null(tcommon) | ! (any(tcommon > 0 & tcommon <= 1) & length(tcommon) > 2))
stop("'tcommon' must be of minimum length 2 with values between 0 and 1.")
}else{
if (! is.null(tcommon) & ! (any(tcommon > 0 & tcommon <= 1) & length(tcommon) > 2))
stop("If tdesign = 'random', 'tcommon' must be either NULL or of minimum length 2 with values between 0 and 1.")
}
if (! class(hurst_fun) == "function")
stop("'hurst_fun' must be a function.")
if (! L > 0)
stop("'L' must be a positive scalar value.")
if (! class(far_kernel) == "function")
stop("'far_kernel' must be bevariate function")
if (! class(far_mean) == "function")
stop("'far_mean' must be a function")
if (! (is.integer(int_grid) & int_grid > 50))
stop("'int_grid' must be an integer greater than 30.")
if (! (is.integer(burnin) & burnin > 30))
stop("'burnin' must be an integer greater than 30.")
if (! class(remove_burnin) == "logical")
stop("'remove_burnin' must be boolean.")
n <- N + burnin
grid <- (1:int_grid) / int_grid
# If random design
if (tdesign == "random"){
dt_rdesign <- .random_design(N = n, lambda = lambda, tdistribution = tdistribution)
M <- dt_rdesign[, .("Mn" = unique(Mn)), by = "id_curve"][, Mn]
dt_far <- data.table::rbindlist(lapply(1:n, function(i, dt_rdesign, grid, tcommon, M, hurst_fun, L){
# Combine design + integration grid + tcommon
tall <- c(dt_rdesign[id_curve == i, Tn], grid, tcommon)
ttag <- c(rep("Tn", M[i]), rep("int_grid", length(grid)), rep("tcommon", length(tcommon)))
dt <- data.table::data.table("id_curve" = i, "tall" = tall, "ttag" = ttag)
dt <- dt[order(tall)]
# Generate and add mfBm
dt_eps <- simulate_mfBm(t = dt[, tall], hurst_fun = hurst_fun, L = L, tied = FALSE)
dt[, eps := dt_eps[, mfBm]]
# Add mean function
dt[, far_mean := far_mean(tall)]
}, dt_rdesign = dt_rdesign, grid = grid, tcommon = tcommon, M = M, hurst_fun = hurst_fun, L = L))
} else {
# Common design case
dt_far <- data.table::rbindlist(lapply(1:n, function(i, tcommon, grid, hurst_fun, L){
# Combine design + integration grid
tall <- c(tcommon, grid)
ttag <- c(rep("tcommon", length(tcommon)), rep("int_grid", length(grid)))
dt <- data.table::data.table("id_curve" = i, "tall" = tall, "ttag" = ttag)
dt <- dt[order(tall)]
# Generate and add mfBm
dt_eps <- simulate_mfBm(t = dt[, tall], hurst_fun = hurst_fun, L = L, tied = FALSE)
dt[, eps := dt_eps[, mfBm]]
# Add mean function
dt[, far_mean := far_mean(tall)]
}, tcommon = tcommon, grid = grid, hurst_fun = hurst_fun, L = L))
}
# Generate FAR(1)
dt_far[id_curve == 1, X := far_mean + eps]
for(i in 2:n){
tall <- dt_far[id_curve == i, tall]
Xold_centred <- dt_far[id_curve == i - 1 & ttag == "int_grid", X - far_mean]
Enew <- dt_far[id_curve == i, eps]
far_mean_new <- dt_far[id_curve == i, far_mean]
tmp <- expand.grid(u = tall, v = grid)
u <- tmp$u
v <- tmp$v
beta <- matrix(far_kernel(u,v), ncol = int_grid, byrow = FALSE)
Xi <- far_mean_new + as.numeric((1/int_grid) * beta %*% matrix(Xold_centred, ncol = 1) + Enew)
dt_far[id_curve == i, X := Xi]
}
# Remove the data for integral approximation
dt_far <- dt_far[ttag != "int_grid"]
if(remove_burnin){
dt_far <- dt_far[! id_curve %in% 1:burnin]
dt_far[, id_curve := id_curve - burnin]
}
return(dt_far)
}
#'                   hurst_fun = hurst_logistic,
#'                   L = 4,
#'                   far_kernel = function(s,t) 9/4 * exp( - (t + 2 * s) ** 2),
#'                   far_mean = function(t) 4 * sin(1.5 * pi * t),
#'                   int_grid = 100L,
#'                   burnin = 100L,
#'                   remove_burnin = TRUE)
#'
#'}
#'
simulate_far <- function(N = 2L, lambda = 70L,
tdesign = "random",
tdistribution = runif,
tcommon = seq(0.2, 0.8, len = 50),
hurst_fun = hurst_logistic,
L = 4,
far_kernel = function(s,t) 9/4 * exp( - (t + 2 * s) ** 2),
far_mean = function(t) 4 * sin(1.5 * pi * t),
int_grid = 100L,
burnin = 100L,
remove_burnin = TRUE) {
if (! is.integer(N) & N > 1)
stop("N' must be an integer greater than 1.")
if (! is.integer(lambda) & lambda > 1)
stop("N' must be an integer greater than 1.")
if (! class(tdesign) == "character"){
stop("'tdesign' must be a character.")
}else{
tdesign <- match.arg(arg = tdesign, choices = c("random", "common"))
}
if (class(tdistribution) != "function" & tdesign == "random")
stop("If tdesign = 'random', then 'tdistribution' must be a function.")
if ((! is.null(tdistribution)) & tdesign == "common")
stop("If tdesign = 'common', then 'tdistribution' must be NULL")
if (tdesign == "common"){
if (is.null(tcommon) | ! (any(tcommon > 0 & tcommon <= 1) & length(tcommon) > 2))
stop("'tcommon' must be of minimum length 2 with values between 0 and 1.")
}else{
if (! is.null(tcommon) & ! (any(tcommon > 0 & tcommon <= 1) & length(tcommon) > 2))
stop("If tdesign = 'random', 'tcommon' must be either NULL or of minimum length 2 with values between 0 and 1.")
}
if (! class(hurst_fun) == "function")
stop("'hurst_fun' must be a function.")
if (! L > 0)
stop("'L' must be a positive scalar value.")
if (! class(far_kernel) == "function")
stop("'far_kernel' must be bevariate function")
if (! class(far_mean) == "function")
stop("'far_mean' must be a function")
if (! (is.integer(int_grid) & int_grid > 50))
stop("'int_grid' must be an integer greater than 30.")
if (! (is.integer(burnin) & burnin > 30))
stop("'burnin' must be an integer greater than 30.")
if (! class(remove_burnin) == "logical")
stop("'remove_burnin' must be boolean.")
n <- N + burnin
grid <- (1:int_grid) / int_grid
# If random design
if (tdesign == "random"){
dt_rdesign <- .random_design(N = n, lambda = lambda, tdistribution = tdistribution)
M <- dt_rdesign[, .("Mn" = unique(Mn)), by = "id_curve"][, Mn]
dt_far <- data.table::rbindlist(lapply(1:n, function(i, dt_rdesign, grid, tcommon, M, hurst_fun, L){
# Combine design + integration grid + tcommon
tall <- c(dt_rdesign[id_curve == i, Tn], grid, tcommon)
ttag <- c(rep("Tn", M[i]), rep("int_grid", length(grid)), rep("tcommon", length(tcommon)))
dt <- data.table::data.table("id_curve" = i, "tall" = tall, "ttag" = ttag)
dt <- dt[order(tall)]
# Generate and add mfBm
dt_eps <- simulate_mfBm(t = dt[, tall], hurst_fun = hurst_fun, L = L, tied = FALSE)
dt[, eps := dt_eps[, mfBm]]
# Add mean function
dt[, far_mean := far_mean(tall)]
}, dt_rdesign = dt_rdesign, grid = grid, tcommon = tcommon, M = M, hurst_fun = hurst_fun, L = L))
} else {
# Common design case
dt_far <- data.table::rbindlist(lapply(1:n, function(i, tcommon, grid, hurst_fun, L){
# Combine design + integration grid
tall <- c(tcommon, grid)
ttag <- c(rep("tcommon", length(tcommon)), rep("int_grid", length(grid)))
dt <- data.table::data.table("id_curve" = i, "tall" = tall, "ttag" = ttag)
dt <- dt[order(tall)]
# Generate and add mfBm
dt_eps <- simulate_mfBm(t = dt[, tall], hurst_fun = hurst_fun, L = L, tied = FALSE)
dt[, eps := dt_eps[, mfBm]]
# Add mean function
dt[, far_mean := far_mean(tall)]
}, tcommon = tcommon, grid = grid, hurst_fun = hurst_fun, L = L))
}
# Generate FAR(1)
dt_far[id_curve == 1, X := far_mean + eps]
for(i in 2:n){
tall <- dt_far[id_curve == i, tall]
Xold_centred <- dt_far[id_curve == i - 1 & ttag == "int_grid", X - far_mean]
Enew <- dt_far[id_curve == i, eps]
far_mean_new <- dt_far[id_curve == i, far_mean]
tmp <- expand.grid(u = tall, v = grid)
u <- tmp$u
v <- tmp$v
beta <- matrix(far_kernel(u,v), ncol = int_grid, byrow = FALSE)
Xi <- far_mean_new + as.numeric((1/int_grid) * beta %*% matrix(Xold_centred, ncol = 1) + Enew)
dt_far[id_curve == i, X := Xi]
}
# Remove the data for integral approximation
dt_far <- dt_far[ttag != "int_grid"]
if(remove_burnin){
dt_far <- dt_far[! id_curve %in% 1:burnin]
dt_far[, id_curve := id_curve - burnin]
}
return(dt_far)
}
dt_far <- simulate_far(N = 2L, lambda = 70L,
tdesign = "common",
tdistribution = runif,
tcommon = seq(0.2, 0.8, len = 50),
hurst_fun = hurst_logistic,
L = 4,
far_kernel = function(s,t) 9/4 * exp( - (t + 2 * s) ** 2),
far_mean = function(t) 4 * sin(1.5 * pi * t),
int_grid = 100L,
burnin = 100L,
remove_burnin = TRUE)
dt_far <- simulate_far(N = 2L, lambda = 70L,
tdesign = "common",
tdistribution = NULL,
tcommon = seq(0.2, 0.8, len = 50),
hurst_fun = hurst_logistic,
L = 4,
far_kernel = function(s,t) 9/4 * exp( - (t + 2 * s) ** 2),
far_mean = function(t) 4 * sin(1.5 * pi * t),
int_grid = 100L,
burnin = 100L,
remove_burnin = TRUE)
dt_far
dt_far
dt_far
dt_far
dt_far
dt_far
data.table::setnames(x = dt_far, old = "tall", new = "tobs")
dt_far
dt_far
View(MASS::mvrnorm)
gc()
gc()
gc()
gc()
gc()
devtools::check()
?is()
f <- function(t) t
is(object = f, class2 = "function")
devtools::check()
devtools::check()
devtools::check()
usethis::use_package("methods")
devtools::check()
devtools::check()
devtools::check()
devtools::check()
