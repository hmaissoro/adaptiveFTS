dygraphs::dygraph(dt_mu)
dt_mu
library(data.table)
library(magrittr)
library(dygraphs)
library(glmnet)
library(fastmatrix)
library(rgl)
library(rglwidget)
# Import data
dt <- fread(file = "../data_electricity/household_voltage_autumn2009_winter2010.csv")
## Empirical mean function
dt_mu <- dt[order(tobs), .("mu" = mean(voltage, na.rm = TRUE)), by = "tobs"]
dygraphs::dygraph(dt_mu)
## Empirical covariance
### E[X(s)X(t)]
dt_x <- data.table::dcast(data = dt, formula = tobs ~ date, value.var = "voltage")
dt_x <- dt_x[order(tobs)]
mat_x <- as.matrix(dt_x[, .SD, .SDcols = ! 'tobs'])
rownames(mat_x) <- dt_x[, tobs]
mat_XsXt <- (1 / ncol(mat_x)) * (mat_x %*% t(mat_x))
### mu(s)mu(t)
dt_mu <- dt_mu[order(tobs)]
mat_mu <- matrix(data = dt_mu[, mu], ncol = 1)
rownames(mat_mu) <- dt_mu[order(tobs), tobs]
mat_musmut <- mat_mu %*% t(mat_mu)
### C(s,t)
mat_cov <- mat_XsXt - mat_musmut
rm(mat_XsXt, mat_x, dt_x)
gc()
gc()
### plot auto covariance
dt_cov <- data.table::as.data.table(expand.grid("s" = tobs, "t" = tobs))
### co-variables
tobs <- dt[, unique(sort(tobs))]
K <- 50
## Empirical covariance
### E[X(s)X(t)]
dt_x <- data.table::dcast(data = dt, formula = tobs ~ date, value.var = "voltage")
dt_x <- dt_x[order(tobs)]
mat_x <- as.matrix(dt_x[, .SD, .SDcols = ! 'tobs'])
rownames(mat_x) <- dt_x[, tobs]
mat_XsXt <- (1 / ncol(mat_x)) * (mat_x %*% t(mat_x))
### mu(s)mu(t)
dt_mu <- dt_mu[order(tobs)]
mat_mu <- matrix(data = dt_mu[, mu], ncol = 1)
rownames(mat_mu) <- dt_mu[order(tobs), tobs]
mat_musmut <- mat_mu %*% t(mat_mu)
### C(s,t)
mat_cov <- mat_XsXt - mat_musmut
rm(mat_XsXt, mat_x, dt_x)
### plot auto covariance
dt_cov <- data.table::as.data.table(expand.grid("s" = tobs, "t" = tobs))
dt_cov <- dt_cov[order(s)]
dt_cov[, c := c(mat_cov)]
rgl::plot3d(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c],
xlab = "s", ylab = "t", zlab = "C(s,t)", type = "l", col = "darkred")
library(plotly)
fig <- rgl::plot3d(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c],
xlab = "s", ylab = "t", zlab = "C(s,t)", type = "shade", col = "darkred")
fig
fig <- rgl::plot3d(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c],
xlab = "s", ylab = "t", zlab = "C(s,t)", type = "shade", col = "darkred")
fig
fig <- rgl::plot3d(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c],
xlab = "s", ylab = "t", zlab = "C(s,t)", type = "wire", col = "darkred")
fig <- plot_ly(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c]) %>% add_surface()
fig
fig <- plot_ly(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c])
fig
dt_cov
dt_cov
?plot_ly
fig <- plot_ly(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c]) %>% add_surface()
fig
dt_cov[, c]
class(dt_cov[, c])
fig <- plot_ly(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c]) %>% add_surface(z = dt_cov[, c])
fig
kd <- with(MASS::geyser, MASS::kde2d(duration, waiting, n = 50))
kd
View(kd)
fig <- plot_ly(x = tobs, y = tobs, z = mat_cov) %>% add_surface()
fig
fig <- rgl::plot3d(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c],
xlab = "s", ylab = "t", zlab = "C(s,t)", type = "l", col = "darkred")
rm(fig)
gc()
### plot C_1(s,t)
plot_ly(x = tobs, y = tobs, z = mat_autocov) %>% add_surface()
### E[X_n(s)X_{n+1}(t)]
d <- dt[, unique(date)]
dt_xn <- dt[! date == d[length(d)]]
dt_xn_plus_1 <- dt[! date == d[1]]
dt_xn <- dt_xn[order(tobs)]
dt_xn_plus_1 <- dt_xn_plus_1[order(tobs)]
dt_xn <- data.table::dcast(data = dt_xn, formula = tobs ~ date, value.var = "voltage")
dt_xn_plus_1 <- data.table::dcast(data = dt_xn_plus_1, formula = tobs ~ date, value.var = "voltage")
mat_xn <- as.matrix(dt_xn[, .SD, .SDcols = ! 'tobs'])
mat_xn_plus_1 <- as.matrix(dt_xn_plus_1[, .SD, .SDcols = ! 'tobs'])
rownames(mat_xn) <- dt_xn[, tobs]
rownames(mat_xn_plus_1) <- dt_xn_plus_1[, tobs]
mat_Xns_Xn_plus_1_t <- (1 / ncol(mat_xn)) * (mat_xn %*% t(mat_xn_plus_1))
### C_1(s,t)
mat_autocov <- mat_Xns_Xn_plus_1_t - mat_musmut
rm(mat_musmut, mat_xn, mat_xn_plus_1, dt_xn_plus_1, dt_xn, mat_Xns_Xn_plus_1_t, d, mat_mu)
### plot C_1(s,t)
plot_ly(x = tobs, y = tobs, z = mat_autocov) %>% add_surface()
library(plot3D)
### plot auto covariance
dt_cov <- data.table::as.data.table(expand.grid("s" = tobs, "t" = tobs))
dt_cov <- dt_cov[order(s)]
dt_cov[, c := c(mat_cov)]
plot3D::surf3D(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c])
?plot3D::surf3D
M <- mesh(seq(0, 6*pi, length.out = 50),seq(pi/3, pi, length.out = 50))
u <- M$x ; v <- M$y
x <- v * cos(u)
y <- v * sin(u)
?mesh
plot3D::surf3D(x = mesh(tobs, tobs), y = mesh(tobs, tobs), z = mat_cov)
mesh(tobs, tobs)
M <- mesh(tobs, tobs)
M$x
M$x %>% View()
M <- mesh(tobs, tobs)
plot3D::surf3D(x = M$x, y = M$y, z = mat_cov)
installed.packages("threejs")
install.packages("threejs")
gc()
gc()
gc()
gc()
gc()
gc()
threejs::scatterplot3js(x = dt_cov[, s], y = dt_cov[, t], z = dt_cov[, c])
gc()
gc()
gc()
library(data.table)
library(magrittr)
library(dygraphs)
library(glmnet)
library(fastmatrix)
# For plot3d
library(rgl)
library(rglwidget)
library(plotly)
# Import data
dt <- fread(file = "../data_electricity/household_voltage_autumn2009_winter2010.csv")
library(data.table)
library(magrittr)
library(dygraphs)
library(glmnet)
library(fastmatrix)
# For plot3d
library(rgl)
library(rglwidget)
library(plotly)
# Import data
dt <- fread(file = "../data_electricity/household_voltage_autumn2009_winter2010.csv")
## Empirical mean function
dt_mu <- dt[order(tobs), .("mu" = mean(voltage, na.rm = TRUE)), by = "tobs"]
dygraphs::dygraph(dt_mu)
### co-variables
tobs <- dt[, unique(sort(tobs))]
K <- 50
cos_mat <- outer(X = tobs, Y = 1:K, function(t, k) sqrt(2) * cos(2 * pi * k * tobs))
colnames(cos_mat) <- paste0("cos", 1:K)
sin_mat <- outer(X = tobs, Y = 1:K, function(t, k) sqrt(2) * sin(2 * pi * k * tobs))
colnames(sin_mat) <- paste0("sin", 1:K)
mat_covariable <- cbind(cos_mat, sin_mat)
### LASSO regression
cv_model <- glmnet::cv.glmnet(x = mat_covariable, y = dt_mu[, mu],
intercept = TRUE, alpha = 1, nfolds = 20)
plot(cv_model)
best_lambda <- cv_model$lambda.min
mu_model <- glmnet::glmnet(x = mat_covariable, y = dt_mu[, mu],
intercept = TRUE, alpha = 1, lambda = best_lambda)
coef <- coef(mu_model)
mu <- predict(mu_model, mat_covariable)
dygraphs::dygraph(data = data.table::data.table(tobs, mu))
mu_fun <- function(t, coef = matrix(data = NA, nrow = 101, ncol = 3)){
m <- coef[, ]
}
## Empirical covariance
### E[X(s)X(t)]
dt_x <- data.table::dcast(data = dt, formula = tobs ~ date, value.var = "voltage")
dt_x <- dt_x[order(tobs)]
mat_x <- as.matrix(dt_x[, .SD, .SDcols = ! 'tobs'])
rownames(mat_x) <- dt_x[, tobs]
mat_XsXt <- (1 / ncol(mat_x)) * (mat_x %*% t(mat_x))
### mu(s)mu(t)
dt_mu <- dt_mu[order(tobs)]
mat_mu <- matrix(data = dt_mu[, mu], ncol = 1)
rownames(mat_mu) <- dt_mu[order(tobs), tobs]
mat_musmut <- mat_mu %*% t(mat_mu)
### C(s,t)
mat_cov <- mat_XsXt - mat_musmut
rm(mat_XsXt, mat_x, dt_x)
### plot auto covariance
dt_cov <- data.table::as.data.table(expand.grid("s" = tobs, "t" = tobs))
dt_cov <- dt_cov[order(s)]
dt_cov[, c := c(mat_cov)]
rm(dt_cov)
gc()
gc()
plot_ly(x = tobs, y = tobs, z = mat_cov) %>% add_surface()
### E[X_n(s)X_{n+1}(t)]
d <- dt[, unique(date)]
dt_xn <- dt[! date == d[length(d)]]
dt_xn_plus_1 <- dt[! date == d[1]]
dt_xn <- dt_xn[order(tobs)]
dt_xn_plus_1 <- dt_xn_plus_1[order(tobs)]
dt_xn <- data.table::dcast(data = dt_xn, formula = tobs ~ date, value.var = "voltage")
dt_xn_plus_1 <- data.table::dcast(data = dt_xn_plus_1, formula = tobs ~ date, value.var = "voltage")
mat_xn <- as.matrix(dt_xn[, .SD, .SDcols = ! 'tobs'])
mat_xn_plus_1 <- as.matrix(dt_xn_plus_1[, .SD, .SDcols = ! 'tobs'])
rownames(mat_xn) <- dt_xn[, tobs]
rownames(mat_xn_plus_1) <- dt_xn_plus_1[, tobs]
mat_Xns_Xn_plus_1_t <- (1 / ncol(mat_xn)) * (mat_xn %*% t(mat_xn_plus_1))
### C_1(s,t)
mat_autocov <- mat_Xns_Xn_plus_1_t - mat_musmut
rm(mat_musmut, mat_xn, mat_xn_plus_1, dt_xn_plus_1, dt_xn, mat_Xns_Xn_plus_1_t, d, mat_mu)
plot_ly(x = tobs, y = tobs, z = mat_cov) %>%
add_surface(
contours = list(
z = list(
show=TRUE,
usecolormap=TRUE,
highlightcolor="#ff0000",
project=list(z=TRUE)
)
))
plot_ly(x = tobs, y = tobs, z = mat_cov) %>%
add_surface()
gc()
gc()
gc()
gc()
gc()
gc()
gc()
gc()
gc()
gc()
gc()
gc()
gc()
library(data.table)
library(magrittr)
library(dygraphs)
library(glmnet)
library(fastmatrix)
# For plot3d
library(rgl)
library(rglwidget)
library(plotly)
# Import data
dt <- fread(file = "../data_electricity/household_voltage_autumn2009_winter2010.csv")
## Empirical mean function
dt_mu <- dt[order(tobs), .("mu" = mean(voltage, na.rm = TRUE)), by = "tobs"]
dygraphs::dygraph(dt_mu)
### co-variables
tobs <- dt[, unique(sort(tobs))]
K <- 50
cos_mat <- outer(X = tobs, Y = 1:K, function(t, k) sqrt(2) * cos(2 * pi * k * tobs))
colnames(cos_mat) <- paste0("cos", 1:K)
sin_mat <- outer(X = tobs, Y = 1:K, function(t, k) sqrt(2) * sin(2 * pi * k * tobs))
colnames(sin_mat) <- paste0("sin", 1:K)
mat_covariable <- cbind(cos_mat, sin_mat)
### LASSO regression
cv_model <- glmnet::cv.glmnet(x = mat_covariable, y = dt_mu[, mu],
intercept = TRUE, alpha = 1, nfolds = 20)
plot(cv_model)
best_lambda <- cv_model$lambda.min
mu_model <- glmnet::glmnet(x = mat_covariable, y = dt_mu[, mu],
intercept = TRUE, alpha = 1, lambda = best_lambda)
coef <- coef(mu_model)
mu <- predict(mu_model, mat_covariable)
dygraphs::dygraph(data = data.table::data.table(tobs, mu))
mu_fun <- function(t, coef = matrix(data = NA, nrow = 101, ncol = 3)){
m <- coef[, ]
}
## Empirical covariance
### E[X(s)X(t)]
dt_x <- data.table::dcast(data = dt, formula = tobs ~ date, value.var = "voltage")
dt_x <- dt_x[order(tobs)]
mat_x <- as.matrix(dt_x[, .SD, .SDcols = ! 'tobs'])
rownames(mat_x) <- dt_x[, tobs]
mat_XsXt <- (1 / ncol(mat_x)) * (mat_x %*% t(mat_x))
### mu(s)mu(t)
dt_mu <- dt_mu[order(tobs)]
mat_mu <- matrix(data = dt_mu[, mu], ncol = 1)
rownames(mat_mu) <- dt_mu[order(tobs), tobs]
mat_musmut <- mat_mu %*% t(mat_mu)
### C(s,t)
mat_cov <- mat_XsXt - mat_musmut
rm(mat_XsXt, mat_x, dt_x)
plot_ly(x = tobs, y = tobs, z = mat_cov) %>%
add_surface(
contours = list(
z = list(
show=TRUE,
usecolormap=TRUE,
highlightcolor="#ff0000",
project=list(z=TRUE)
)
))
plot_ly(x = tobs, y = tobs, z = mat_cov) %>%
add_surface()
### E[X_n(s)X_{n+1}(t)]
d <- dt[, unique(date)]
dt_xn <- dt[! date == d[length(d)]]
dt_xn_plus_1 <- dt[! date == d[1]]
dt_xn <- dt_xn[order(tobs)]
dt_xn_plus_1 <- dt_xn_plus_1[order(tobs)]
dt_xn <- data.table::dcast(data = dt_xn, formula = tobs ~ date, value.var = "voltage")
dt_xn_plus_1 <- data.table::dcast(data = dt_xn_plus_1, formula = tobs ~ date, value.var = "voltage")
mat_xn <- as.matrix(dt_xn[, .SD, .SDcols = ! 'tobs'])
mat_xn_plus_1 <- as.matrix(dt_xn_plus_1[, .SD, .SDcols = ! 'tobs'])
rownames(mat_xn) <- dt_xn[, tobs]
rownames(mat_xn_plus_1) <- dt_xn_plus_1[, tobs]
mat_Xns_Xn_plus_1_t <- (1 / ncol(mat_xn)) * (mat_xn %*% t(mat_xn_plus_1))
### C_1(s,t)
mat_autocov <- mat_Xns_Xn_plus_1_t - mat_musmut
rm(mat_musmut, mat_xn, mat_xn_plus_1, dt_xn_plus_1, dt_xn, mat_Xns_Xn_plus_1_t, d, mat_mu)
### plot C_1(s,t)
plot_ly(x = tobs, y = tobs, z = mat_autocov, ) %>% add_surface()
gc()
gc()
### fourier basis
tobs <- dt[, unique(sort(tobs))]
L <- 5
cos_mat <- outer(X = tobs, Y = 1:L, function(t, l) sqrt(2) * cos(2 * pi * l * tobs))
colnames(cos_mat) <- paste0("cos", 1:L)
sin_mat <- outer(X = tobs, Y = 1:L, function(t, l) sqrt(2) * sin(2 * pi * l * tobs))
colnames(sin_mat) <- paste0("sin", 1:L)
theta <- cbind(1, cos_mat, sin_mat)
eta <- cbind(1, cos_mat, sin_mat)
dim(eta)
### Compute Z_l(s) = \int_{0}^{1} c(s,u) theta(u) du
ZZ <- (1 / length(tobs)) * mat_cov %*% theta
### Compute the co variable matrix
### Note that the following is faster then : FF <- kronecker(ZZ, eta)
FF <- fastmatrix::kronecker.prod(ZZ, eta)
### Compute the dependent variable vector
### Note that c(matrix) = (matrix[, 1], matrix[, 2], ..., matrix[, ncol(matrix)])
### Thus by doing...
CC1 <- c(mat_autocov)
rm(mat_autocov, mat_cov, ZZ, theta, eta, cos_mat, sin_mat)
gc()
gc()
### Lasso regression
beta_cv_model <- glmnet::cv.glmnet(x = FF, y = CC1,
intercept = FALSE, alpha = 1, nfolds = 20)
gc()
gc()
gc()
### Lasso regression
beta_cv_model <- glmnet::cv.glmnet(x = FF, y = CC1,
intercept = FALSE, alpha = 1, nfolds = 20)
plot(beta_cv_model)
beta_lambda <- beta_cv_model$lambda.min
beta_lambda
beta_model <- glmnet::glmnet(x = FF, y = CC1,
intercept = FALSE, alpha = 1, lambda = beta_lambda)
CC1_prev <- predict(beta_model, FF)
coef <- coef(beta_model)
coef
beta_coef <- coef(beta_model)
### plot C_1(s,t)
plot_ly(x = tobs, y = tobs, z = mat_autocov) %>% add_surface()
### E[X_n(s)X_{n+1}(t)]
d <- dt[, unique(date)]
dt_xn <- dt[! date == d[length(d)]]
dt_xn_plus_1 <- dt[! date == d[1]]
dt_xn <- dt_xn[order(tobs)]
dt_xn_plus_1 <- dt_xn_plus_1[order(tobs)]
dt_xn <- data.table::dcast(data = dt_xn, formula = tobs ~ date, value.var = "voltage")
dt_xn_plus_1 <- data.table::dcast(data = dt_xn_plus_1, formula = tobs ~ date, value.var = "voltage")
mat_xn <- as.matrix(dt_xn[, .SD, .SDcols = ! 'tobs'])
mat_xn_plus_1 <- as.matrix(dt_xn_plus_1[, .SD, .SDcols = ! 'tobs'])
rownames(mat_xn) <- dt_xn[, tobs]
rownames(mat_xn_plus_1) <- dt_xn_plus_1[, tobs]
mat_Xns_Xn_plus_1_t <- (1 / ncol(mat_xn)) * (mat_xn %*% t(mat_xn_plus_1))
### C_1(s,t)
mat_autocov <- mat_Xns_Xn_plus_1_t - mat_musmut
rm(mat_musmut, mat_xn, mat_xn_plus_1, dt_xn_plus_1, dt_xn, mat_Xns_Xn_plus_1_t, d, mat_mu)
### plot C_1(s,t)
plot_ly(x = tobs, y = tobs, z = mat_autocov) %>% add_surface()
### mu(s)mu(t)
dt_mu <- dt_mu[order(tobs)]
mat_mu <- matrix(data = dt_mu[, mu], ncol = 1)
rownames(mat_mu) <- dt_mu[order(tobs), tobs]
mat_musmut <- mat_mu %*% t(mat_mu)
### C(s,t)
mat_cov <- mat_XsXt - mat_musmut
### E[X_n(s)X_{n+1}(t)]
d <- dt[, unique(date)]
dt_xn <- dt[! date == d[length(d)]]
dt_xn_plus_1 <- dt[! date == d[1]]
dt_xn <- dt_xn[order(tobs)]
dt_xn_plus_1 <- dt_xn_plus_1[order(tobs)]
dt_xn <- data.table::dcast(data = dt_xn, formula = tobs ~ date, value.var = "voltage")
dt_xn_plus_1 <- data.table::dcast(data = dt_xn_plus_1, formula = tobs ~ date, value.var = "voltage")
mat_xn <- as.matrix(dt_xn[, .SD, .SDcols = ! 'tobs'])
mat_xn_plus_1 <- as.matrix(dt_xn_plus_1[, .SD, .SDcols = ! 'tobs'])
rownames(mat_xn) <- dt_xn[, tobs]
rownames(mat_xn_plus_1) <- dt_xn_plus_1[, tobs]
mat_Xns_Xn_plus_1_t <- (1 / ncol(mat_xn)) * (mat_xn %*% t(mat_xn_plus_1))
### C_1(s,t)
mat_autocov <- mat_Xns_Xn_plus_1_t - mat_musmut
rm(mat_musmut, mat_xn, mat_xn_plus_1, dt_xn_plus_1, dt_xn, mat_Xns_Xn_plus_1_t, d, mat_mu)
### plot C_1(s,t)
plot_ly(x = tobs, y = tobs, z = mat_autocov) %>% add_surface()
##
plot_ly(x = tobs, y = tobs, z = matrix(CC1_prev, ncol = length(tobs))) %>% add_surface()
gc()
gc()
gc()
sin(2*pi)
sin(2*pi*10)
sin(2* 3.14)
.sin
?sin
sin(2 * pi)
sin(3 * pi)
sin(4 * pi)
sin(pi)
sin(0)
cos(pi)
cos(0)
base::sin(pi)
base::sin(0)
base::sin(2 * pi)
base::cos(pi)
base::sin(pi/2)
(1:1440) / 1440
?integrate
integrate(f = function(u) sqrt(2) * sin(2 * pi, u), lower = 0, upper = 1)
fsin <- function(u) sqrt(2) * sin(2 * pi * u)
integrate(f = sin, lower = 0, upper = 1)
integral <- unlist(lapply(1:50, function(k){
fsin <- function(u) sqrt(2) * sin(2 * pi * k * u)
integrate(f = sin, lower = 0, upper = 1)
}))
int_sin <- unlist(lapply(1:50, function(k){
fsin <- function(u) sqrt(2) * sin(2 * pi * k * u)
integrate(f = sin, lower = 0, upper = 1)
}))
int_sin <- unlist(lapply(1:50, function(k){
fsin <- function(u) sqrt(2) * sin(2 * pi * k * u)
integrate(f = sin, lower = 0, upper = 1)
}))
int_sin
int_sin <- unlist(lapply(1:50, function(k){
fsin <- function(u) sqrt(2) * sin(2 * pi * k * u)
integrate(f = sin, lower = 0, upper = 1)$value
}))
int_cos <- unlist(lapply(1:50, function(k){
fcos <- function(u) sqrt(2) * cos(2 * pi * k * u)
integrate(f = sin, lower = 0, upper = 1)$value
}))
int_cos
int_sin <- unlist(lapply(1:50, function(k){
fsin <- function(u) sqrt(2) * sin(2 * pi * k * u)
integrate(f = fsin, lower = 0, upper = 1)$value
}))
int_cos <- unlist(lapply(1:50, function(k){
fcos <- function(u) sqrt(2) * cos(2 * pi * k * u)
integrate(f = fcos, lower = 0, upper = 1)$value
}))
int_sin
int_cos <- unlist(lapply(1:50, function(k){
fcos <- function(u) sqrt(2) * cos(2 * pi * k * u)
integrate(f = fcos, lower = 0, upper = 1)$value
}))
int_cos
int_sin <- unlist(lapply(1:50, function(k){
fsin <- function(u) sqrt(2) * abs(sin(2 * pi * k * u))
integrate(f = fsin, lower = 0, upper = 1)$value
}))
fsin <- function(u) sqrt(2) * abs(sin(2 * pi * k * u))
integrate(f = fsin, lower = 0, upper = 1)$value
k <- 1
integrate(f = fsin, lower = 0, upper = 1)$value
int_sin <- unlist(lapply(1:50, function(k){
fsin <- function(u) sqrt(2) * abs(sin(2 * pi * k * u))
integrate(f = fsin, lower = 0, upper = 1)$value
}))
int_cos <- unlist(lapply(1:50, function(k){
fcos <- function(u) sqrt(2) * abs(cos(2 * pi * k * u))
integrate(f = fcos, lower = 0, upper = 1)$value
}))
int_sin <- unlist(lapply(1:50, function(k){
fsin <- function(u) sqrt(2) * sin(2 * pi * k * u)
integrate(f = fsin, lower = 0, upper = 1)$value
}))
int_cos <- unlist(lapply(1:50, function(k){
fcos <- function(u) sqrt(2) * cos(2 * pi * k * u)
integrate(f = fcos, lower = 0, upper = 1)$value
}))
int_cos
abs(int_cos)
max(abs(int_cos))
max(abs(int_sin))
max(abs(int_cos))
gc()
gc()
gc()
gc()
