library("covr")
install.packages(c("roxygen2", "testthat", "usethis", "covr"))
#'
#' @examples
#'
#' t0 <- seq(0.2, 0.8, len = 10)
#' htan <- hurst_atan(t = t0)
#' plot(x = t0, htan, type = "l", col = "red")
#'
#'
#' @seealso \code{\link{hurst_linear}}, \code{\link{hurst_logistic}}
#'
hurst_arctan <- function(t = seq(0.2, 0.8, len = 10)){
atan(t) / pi + 0.5
}
t0 <- seq(0.2, 0.8, len = 10)
htan <- hurst_atan(t = t0)
htan <- hurst_arctan(t = t0)
plot(x = t0, htan, type = "l", col = "red")
#' @export
#'
#' @seealso \code{\link{hurst_arctan}}, \code{\link{hurst_logistic}}.
#'
#' @examples
#' t0 <- seq(0.2, 0.8, len = 10)
#' htan <- hurst_arctan(t = t0)
#' plot(x = t0, htan, type = "l", col = "red")
#'
#'
hurst_linear <- function(t = seq(0.2, 0.8, len = 10), h_left = 0.2, h_right = 0.8) {
t1 <- max(t)
t0 <- min(t)
a <- (h_right - h_left) / (t1 - t0)
b <- h_right - a * t1
pmin(a * t + b, 1)
}
#' @export
#'
#' @seealso \code{\link{hurst_arctan}}, \code{\link{hurst_logistic}}.
#'
#' @examples
#' t0 <- seq(0.2, 0.8, len = 10)
#' htan <- hurst_arctan(t = t0)
#' plot(x = t0, htan, type = "l", col = "red")
#'
#'
hurst_linear <- function(t = seq(0.2, 0.8, len = 10), h_left = 0.2, h_right = 0.8) {
t1 <- 1
t0 <- 0
a <- (h_right - h_left) / (t1 - t0)
b <- h_right - a * t1
pmin(a * t + b, 1)
}
hlinear <- hurst_linear(t = t0)
plot(x = t0, hlinear, type = "l", col = "red")
hlogistic <- hurst_logistic(t = t0, h_left = 0.2,
h_right = 0.8, slope = 30,
change_point_position = 0.5)
#' @seealso \code{\link{hurst_arctan}}, \code{\link{hurst_linear}}.
#'
#' @examples
#' t0 <- seq(0.2, 0.8, len = 10)
#' hlogistic <- hurst_logistic(t = t0, h_left = 0.2,
#'                             h_right = 0.8, slope = 30,
#'                             change_point_position = 0.5)
#' plot(x = t0, y = hlogistic, type = "l", col = "red")
#'
#'
hurst_logistic <- function(t, h_left = 0.2, h_right = 0.8, slope = 30,
change_point_position = 0.5) {
# change_point <- change_point_position * (max(t) + min(t))
# u <- (t - change_point) / (max(t) - min(t))
u <- (t - change_point_position) / (1 - 0)
(h_right - h_left) / (1 + exp(- slope * u)) + h_left
}
#' @seealso \code{\link{hurst_arctan}}, \code{\link{hurst_linear}}.
#'
#' @examples
#' t0 <- seq(0.2, 0.8, len = 10)
#' hlogistic <- hurst_logistic(t = t0, h_left = 0.2,
#'                             h_right = 0.8, slope = 30,
#'                             change_point_position = 0.5)
#' plot(x = t0, y = hlogistic, type = "l", col = "red")
#'
#'
hurst_logistic <- function(t, h_left = 0.2, h_right = 0.8, slope = 30,
change_point_position = 0.5) {
# change_point <- change_point_position * (max(t) + min(t))
# u <- (t - change_point) / (max(t) - min(t))
u <- (t - change_point_position) / (1 - 0)
(h_right - h_left) / (1 + exp(- slope * u)) + h_left
}
hlogistic <- hurst_logistic(t = t0, h_left = 0.2,
h_right = 0.8, slope = 30,
change_point_position = 0.5)
plot(x = t0, y = hlogistic, type = "l", col = "red")
plot(x = t0, y = hlogistic, type = "b", col = "red")
#' @examples
#' Title
#'
#' @param t \code{vector (float)}. Points in [0,1] at which to compute the covariance function.
#' @param hurst_fun \code{function}. Hurst function. It can be \code{\link{hurst_arctan}}, \code{\link{hurst_linear}}, \code{\link{hurst_logistic}}.
#' @param ... Hurst function additional arguments.
#'
#' @return a \code{matrix} of \code{t} x \code{t} covariance.
#' @export
#'
#' @examples
.covariance_mfBm <- function(t = seq(0.2, 0.8, len = 10), hurst_fun = hurst_logistic, ...) {
tmp <- expand.grid(u = t, v = t)
u <- tmp$u
v <- tmp$v
hu <- hurst_fun(u, ...)
hv <- hurst_fun(v, ...)
hh <- hu + hv
values <- constant_d(hu, hv) *
(u**hh + v**hh - abs(u - v) ** hh)
mat <- matrix(values, ncol = length(t))
return(mat)
}
#' @param ... Hurst function additional arguments.
#'
#' @return A \code{data.table} containing 2 column : \code{t} and \code{mfBm}, the sample path.
#'
#' @importFrom MASS mvrnorm
#'
#' @export
#'
#' @examples
#'
simulate_mfBm <- function(t = seq(0.2, 0.8, len = 50), hurst_fun = hurst_logistic, L = 1, tied = TRUE, ...) {
t <- sort(t)
cov_mat <- .covariance_mfBm(t = , hurst_fun = hurst_fun, ...)
out <- MASS::mvrnorm(1,
mu = rep(0, ncol(cov_mat)),
Sigma = L * cov_mat)
mfBm_path <- out - tied*times*out[length(out)]
data.table::data.table("t" = t, mfBm = mfBm_path)
}
simulate_mfBm(t = seq(0.2, 0.8, len = 50), hurst_fun = hurst_logistic, L = 1, tied = TRUE, ...)
simulate_mfBm(t = seq(0.2, 0.8, len = 50), hurst_fun = hurst_logistic, L = 1, tied = TRUE)
#' See the following paper https://doi.org/10.3390/fractalfract6020074.
#'
#' @param x \code{Float (positive)}. First argument of the function.
#' @param y \code{Float (positive)}. Second argument of the function.
#'
#' @return A positive \code{Float} corresponding to the value the function evaluate at (x,y).
#' @export
#'
#' @examples
#'
.constant_d <- function(x, y) {
a <- gamma(2 * x + 1) * gamma(2 * y + 1) * sin(pi * x) * sin(pi * y)
b <- 2 * gamma(x + y + 1) * sin(pi * (x + y) / 2)
val <- sqrt(a) / b
return(val)
}
simulate_mfBm(t = seq(0.2, 0.8, len = 50), hurst_fun = hurst_logistic, L = 1, tied = TRUE)
#' Title
#'
#' @param t \code{vector (float)}. Points in [0,1] at which to compute the covariance function.
#' @param hurst_fun \code{function}. Hurst function. It can be \code{\link{hurst_arctan}}, \code{\link{hurst_linear}}, \code{\link{hurst_logistic}}.
#' @param ... Hurst function additional arguments.
#'
#' @return a \code{matrix} of \code{t} x \code{t} covariance.
#' @export
#'
#' @examples
.covariance_mfBm <- function(t = seq(0.2, 0.8, len = 10), hurst_fun = hurst_logistic, ...) {
tmp <- expand.grid(u = t, v = t)
u <- tmp$u
v <- tmp$v
hu <- hurst_fun(u, ...)
hv <- hurst_fun(v, ...)
hh <- hu + hv
values <- .constant_d(hu, hv) *
(u**hh + v**hh - abs(u - v) ** hh)
mat <- matrix(values, ncol = length(t))
return(mat)
}
simulate_mfBm(t = seq(0.2, 0.8, len = 50), hurst_fun = hurst_logistic, L = 1, tied = TRUE)
#' @param ... Hurst function additional arguments.
#'
#' @return A \code{data.table} containing 2 column : \code{t} and \code{mfBm}, the sample path.
#'
#' @importFrom MASS mvrnorm
#'
#' @export
#'
#' @examples
#'
simulate_mfBm <- function(t = seq(0.2, 0.8, len = 50), hurst_fun = hurst_logistic, L = 1, tied = TRUE, ...) {
t <- sort(t)
cov_mat <- .covariance_mfBm(t = t, hurst_fun = hurst_fun, ...)
out <- MASS::mvrnorm(1,
mu = rep(0, ncol(cov_mat)),
Sigma = L * cov_mat)
mfBm_path <- out - tied * t * out[length(out)]
data.table::data.table("t" = t, mfBm = mfBm_path)
}
simulate_mfBm(t = seq(0.2, 0.8, len = 50), hurst_fun = hurst_logistic, L = 1, tied = TRUE)
devtools::check()
devtools::check()
#' @param hurst \code{float (positive)}. The Hurst exponent scalar value in [0,1].
#' @param L \code{float (positive)}. Hölder constant.
#' @param tied \code{boolean}. If \code{TRUE}, the sample path is tied-down.
#'
#' @return A \code{data.table} containing 2 column : \code{t} and \code{mfBm}, the sample path.
#'
#' @importFrom MASS mvrnorm
#' @importFrom data.table data.table
#'
#' @examples
simulate_fBm <- function(t, hurst = 0.6, L = 1, tied = TRUE) {
tmp <- expand.grid(u = t, v = t)
u <- tmp$u
v <- tmp$v
values <- (1 / 2) *
(u ** hurst + v ** hurst - abs(u - v) ** hurst)
cov_mat <- matrix(values, ncol = length(t))
out <- MASS::mvrnorm(1,
mu = rep(0, ncol(cov_mat)),
Sigma = L * cov_mat)
fBm_path <- out - tied * t * out[length(out)]
dt <- data.table::data.table("t" = t, "fBm" = fBm)
return(dt)
}
simulate_fBm(t = seq(0.2, 0.8, len = 50), hurst = 0.6, L = 1, tied = TRUE)
#' @param hurst \code{float (positive)}. The Hurst exponent scalar value in [0,1].
#' @param L \code{float (positive)}. Hölder constant.
#' @param tied \code{boolean}. If \code{TRUE}, the sample path is tied-down.
#'
#' @return A \code{data.table} containing 2 column : \code{t} and \code{mfBm}, the sample path.
#'
#' @importFrom MASS mvrnorm
#' @importFrom data.table data.table
#'
#' @examples
simulate_fBm <- function(t, hurst = 0.6, L = 1, tied = TRUE) {
tmp <- expand.grid(u = t, v = t)
u <- tmp$u
v <- tmp$v
values <- (1 / 2) *
(u ** hurst + v ** hurst - abs(u - v) ** hurst)
cov_mat <- matrix(values, ncol = length(t))
out <- MASS::mvrnorm(1,
mu = rep(0, ncol(cov_mat)),
Sigma = L * cov_mat)
fBm_path <- out - tied * t * out[length(out)]
dt <- data.table::data.table("t" = t, "fBm" = fBm_path)
return(dt)
}
simulate_fBm(t = seq(0.2, 0.8, len = 50), hurst = 0.6, L = 1, tied = TRUE)
t0 <- seq(0.2, 0.8, len = 20)
dt_fBm <- simulate_fBm(t = t0, hurst = 0.6, L = 1, tied = TRUE)
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
dt_fBm <- simulate_fBm(t = t0, hurst = 0.6, L = 1, tied = TRUE)
plot(x = dt_fBm$t, y = dt_fBm$fBm, type = "l", col = "red")
View(MASS::mvrnorm)
?eigen
devtools::check()
devtools::check()
usethis::use_package("MASS")
usethis::use_package("data.table")
gc()
gc()
devtools::check()
devtools::check()
usethis::use_agpl3_license("Datastorm")
usethis::use_agpl3_license()
devtools::check()
devtools::check()
?eigen
far_mean = function(t) 4 * sin(1.5 * pi * t)
class(far_mean)
is.integer(-2)
tdistribution = runif
class(tdistribution)
